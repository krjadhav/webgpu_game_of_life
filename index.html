<!DOCTYPE html>

<html>
    <head>
        <meta charset="UTF-8">
        <title>WebGPU Game of Life</title>
    </head>
    
    <body>
        <canvas width="512" height="512"></canvas>
    
        <script type="module">
            // Using module let's you use await without needing to wrap everything in an async function
            // Useful for WebGPU initialization
            
            const GRID_SIZE = 32;
            const UPDATE_INTERVAL = 200; // update every 200ms
            let step = 0; // Track how many simulation steps have been run
            
            
            // Canvas is where WebGPU will render to
            const canvas = document.querySelector("canvas");
            
            // Check if WebGPU is supported in the browser -->
            if (!navigator.gpu) {
                throw new Error("WebGPU not supported on this browser.");
            }
            
            // Request access to GPU
            const adapter = await navigator.gpu.requestAdapter();
            if (!adapter) {
                throw new Error("No appropriate GPUAdapter found.");
            }
            
            const device = await adapter.requestDevice();
            
            // Configure Canvas
            const context = canvas.getContext("webgpu"); // target where WebGPU will render to
            const canvasFormat = navigator.gpu.getPreferredCanvasFormat(); // get ideal pixel format for the canvas
            context.configure({ // configure webgpu context
                device: device,
                format: canvasFormat
            });
            
            
            // Define vertices
            // Typed arrays in JS lets you allocate continuous memory blocks.
            // They tend to be more perfomant than regular arrays
            // Float32Array is a typed array that stores 32-bit floating point numbers
            const vertices = new Float32Array([
                // positions
                -0.8, -0.8, // Triangle 1
                0.8, -0.8,
                0.8, 0.8,
                
                -0.8, -0.8, // Triangle 2
                0.8, 0.8,
                -0.8, 0.8,
            ]);
            
            // Create a vertex buffer
            // GPUs can't acess JS memory directly so memory must be allocated on the GPU
            // This is managed through GPUBuffer
            const vertexBuffer = device.createBuffer({
                label: "Cell vertices",
                size: vertices.byteLength,
                usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,
            });
            
            device.queue.writeBuffer(vertexBuffer, 0, vertices);
            
            // Define the vertex layout
            // Each vertex has 2 components (x, y)
            // Each component is a 32-bit float = 4 bytes
            // So 2 components x and y take 8 bytes of memory
            const vertexBufferLayout = {
                arrayStride: 8, // how far to move in memory to get to the next vertex
                attributes: [
                    {
                        format: "float32x2", // each vertext has 2 floating point numbers
                        offset: 0, // how many bytes into the vertex the attribute starts
                        shaderLocation: 0, // arbitary number from 0 - 15 to identify vertex shader
                    }
                ]
            }
            
            //  Create Shaders 
            // Code is written in WSGL (WebGPU Shading Language)
            // vertex function takes a 2D position and returns a 4D position that WebGPU needs for rendering
            // fragment function returns a color for each pixel, so red here
            const cellShaderModule = device.createShaderModule({
                label: "Cell shader",
                code: `

                // replace individual param with structured input/output
                struct VertexInput {
                    @location(0) pos: vec2f,
                    @builtin(instance_index) instance: u32,
                }

                struct VertexOutput {
                    @builtin(position) pos: vec4f,
                    @location(0) cell: vec2f,
                }
                    

                // gets the grid size from JS
                @group(0) @binding(0) var<uniform> grid: vec2f;
                @group(0) @binding(1) var<storage> cellState: array<u32>;
                    
                // takes pos from the vertex buffer (square corner) and instance (0 - 1023 since 32x32 grid)
                @vertex
                fn vertexMain(input: VertexInput) -> VertexOutput {
                    
                    // converts instance number to a float for math operations
                    let i = f32(input.instance);

                    // converts it into grid coordinates
                    let cell = vec2f(i % grid.x, floor(i / grid.x));

                    // gets the cell state
                    let state = f32(cellState[input.instance]);

                    // positions it correctly in the grid
                    let cellOffset = cell / grid * 2;

                    // scales the position based on the cell's state
                    let gridPos = (input.pos*state+1)/grid - 1 + cellOffset;
                    
                    // returns final pos in WebGPU coordinate system
                    var output: VertexOutput;
                    output.pos = vec4f(gridPos, 0, 1);
                    output.cell = cell;
                    return output;
                }
                struct FragInput{
                @location(0) cell: vec2f, // Receives cell coordinates from vertex shader
                };

                // For each pixel of each square
                // - creates a color based on the cell coordinates
                @fragment
                fn fragmentMain(input: FragInput) -> @location(0) vec4f {
                    let c = input.cell/grid;
                    return vec4f(c, 1-c.x, 1);
                }
                `
            });
                        
            // Create a pipeline that renders a cell
            const cellPipeline = device.createRenderPipeline({
                label: "Cell pipeline",
                layout: "auto", // let webgpu decide memory layout
                vertex: {
                    module: cellShaderModule, // pass shader program
                    entryPoint: "vertexMain", // function entrypoint @vertex
                    buffers: [vertexBufferLayout],
                },
                fragment: {
                    module: cellShaderModule,
                    entryPoint: "fragmentMain", // function entrypoint @fragment
                    targets: [
                        {
                            format: canvasFormat, // pixel format to match canvas
                        }
                    ],
                },
            });

            // Create a uniform buffer that describes the grid
            const uniformArray = new Float32Array([GRID_SIZE, GRID_SIZE]);
            const uniformBuffer = device.createBuffer({
                label: "Grid buffer",
                size: uniformArray.byteLength,
                usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
            });
            device.queue.writeBuffer(uniformBuffer, 0, uniformArray);

            // Create storage buffer
            const cellStateArray = new Uint32Array(GRID_SIZE * GRID_SIZE);

            // Create two storage buffer to hold the cell state to implement ping pong scheme
            const cellStateStorage = [
                device.createBuffer({
                    label: "Cell State A",
                    size: cellStateArray.byteLength,
                    usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,
                }),
                device.createBuffer({
                    label: "Cell State B",
                    size: cellStateArray.byteLength,
                    usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,
                })
            ];
            device.queue.writeBuffer(cellStateStorage[0], 0, cellStateArray);

            // Mark every third cell of the grid as active
            for (let i = 0; i < cellStateArray.length; i += 3) {
                cellStateArray[i] = 1;
            }
            device.queue.writeBuffer(cellStateStorage[0], 0, cellStateArray);


            // Mark everty other cell of the second grid as active
            for (let i = 0; i < cellStateArray.length; i++) {
                cellStateArray[i] = i % 2;
            }
            device.queue.writeBuffer(cellStateStorage[1], 0, cellStateArray);

            // Create a bind group to pass the grid uniforms into the pipeline
            // Unlike vertex data which is a fixed part of the pipeline's vertex state
            // Uniforms are dynamic and can change between draw calls
            // So, we need to explicitly create a bind group to pass the uniforms into the pipeline
            const bindGroup = [
                device.createBindGroup({
                    label: "Cell renderer bind group A",
                    layout: cellPipeline.getBindGroupLayout(0),
                    entries: [{
                    binding: 0,
                    resource: { buffer: uniformBuffer }
                    }, {
                    binding: 1,
                    resource: { buffer: cellStateStorage[0] }
                    }],
                }),
                device.createBindGroup({
                    label: "Cell renderer bind group B",
                    layout: cellPipeline.getBindGroupLayout(0),
                    entries: [{
                    binding: 0,
                    resource: { buffer: uniformBuffer }
                    }, {
                    binding: 1,
                    resource: { buffer: cellStateStorage[1] }
                    }], 
                })
            ];

            function updateGrid() {
                // Increment the step count
                step++;

                // Clear the canvas with solid color
                const encoder = device.createCommandEncoder(); // records sequence of GPU commands to be executed later
                const pass = encoder.beginRenderPass({ // collection of draw commands that target canvas
                colorAttachments: [
                    {
                        view: context.getCurrentTexture().createView(), // what to render to
                        loadOp: 'clear', // clear the texture when the pass starts
                        storeOp: 'store', // store the result after rendering
                        clearValue: { r: 0.0, g: 0.0, b: 0.4, a: 1.0 }, // dark blue color
                    }
                ]
                });
                
                // Draw the square
                pass.setPipeline(cellPipeline);
                pass.setVertexBuffer(0, vertexBuffer);
                pass.setBindGroup(0, bindGroup[step % 2]);
                pass.draw(vertices.length / 2, GRID_SIZE * GRID_SIZE);
                        
                // finalize the command buffer and submits it to the GPU for execution
                pass.end()
                device.queue.submit([encoder.finish()]);
                
            }
        // Schedule updateGrid() to run repeatedly
        setInterval(updateGrid, UPDATE_INTERVAL);
        </script>
    </body>
</html>
