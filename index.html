<!DOCTYPE html>

<html>
    <head>
        <meta charset="UTF-8">
        <title>WebGPU Game of Life</title>
    </head>
    
    <body>
        <canvas width="512" height="512"></canvas>
    
        <script type="module">
            // Using module let's you use await without needing to wrap everything in an async function
            // Useful for WebGPU initialization
            
            const GRID_SIZE = 32;
            
            
            // Canvas is where WebGPU will render to
            const canvas = document.querySelector("canvas");
            
            // Check if WebGPU is supported in the browser -->
            if (!navigator.gpu) {
                throw new Error("WebGPU not supported on this browser.");
            }
            
            // Request access to GPU
            const adapter = await navigator.gpu.requestAdapter();
            if (!adapter) {
                throw new Error("No appropriate GPUAdapter found.");
            }
            
            const device = await adapter.requestDevice();
            
            // Configure Canvas
            const context = canvas.getContext("webgpu"); // target where WebGPU will render to
            const canvasFormat = navigator.gpu.getPreferredCanvasFormat(); // get ideal pixel format for the canvas
            context.configure({ // configure webgpu context
                device: device,
                format: canvasFormat
            });
            
            
            // Define vertices
            // Typed arrays in JS lets you allocate continuous memory blocks.
            // They tend to be more perfomant than regular arrays
            // Float32Array is a typed array that stores 32-bit floating point numbers
            const vertices = new Float32Array([
                // positions
                -0.8, -0.8, // Triangle 1
                0.8, -0.8,
                0.8, 0.8,
                
                -0.8, -0.8, // Triangle 2
                0.8, 0.8,
                -0.8, 0.8,
            ]);
            
            // Create a vertex buffer
            // GPUs can't acess JS memory directly so memory must be allocated on the GPU
            // This is managed through GPUBuffer
            const vertexBuffer = device.createBuffer({
                label: "Cell vertices",
                size: vertices.byteLength,
                usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,
            });
            
            device.queue.writeBuffer(vertexBuffer, 0, vertices);
            
            // Define the vertex layout
            // Each vertex has 2 components (x, y)
            // Each component is a 32-bit float = 4 bytes
            // So 2 components x and y take 8 bytes of memory
            const vertexBufferLayout = {
                arrayStride: 8, // how far to move in memory to get to the next vertex
                attributes: [
                    {
                        format: "float32x2", // each vertext has 2 floating point numbers
                        offset: 0, // how many bytes into the vertex the attribute starts
                        shaderLocation: 0, // arbitary number from 0 - 15 to identify vertex shader
                    }
                ]
            }
            
            //  Create Shaders 
            // Code is written in WSGL (WebGPU Shading Language)
            // vertex function takes a 2D position and returns a 4D position that WebGPU needs for rendering
            // fragment function returns a color for each pixel, so red here
            const cellShaderModule = device.createShaderModule({
                label: "Cell shader",
                code: `
                // gets the grid size from JS
                @group(0) @binding(0) var<uniform> grid: vec2f;
                    
                // takes pos from the vertex buffer (square corner) and instance (0 - 1023 since 32x32 grid)
                @vertex
                fn vertexMain(@location(0) pos: vec2f, @builtin(instance_index) instance: u32) ->
                    @builtin(position) vec4f {
                    
                    // converts instance number to a float for math operations
                    let i = f32(instance);

                    // converts it into grid coordinates
                    let cell = vec2f(i % grid.x, floor(i / grid.x));

                    // positions it correctly in the grid
                    let cellOffset = cell / grid * 2;
                    let gridPos = (pos + 1)/grid - 1 + cellOffset;
                    
                    // returns final pos in WebGPU coordinate system
                    return vec4f(gridPos, 0, 1);
                }
                    
                @fragment
                fn fragmentMain() -> @location(0) vec4f {
                    return vec4f(1, 0, 0, 1);
                }
                `
            });
                        
            // Create a pipeline that renders a cell
            const cellPipeline = device.createRenderPipeline({
                label: "Cell pipeline",
                layout: "auto", // let webgpu decide memory layout
                vertex: {
                    module: cellShaderModule, // pass shader program
                    entryPoint: "vertexMain", // function entrypoint @vertex
                    buffers: [vertexBufferLayout],
                },
                fragment: {
                    module: cellShaderModule,
                    entryPoint: "fragmentMain", // function entrypoint @fragment
                    targets: [
                        {
                            format: canvasFormat, // pixel format to match canvas
                        }
                    ],
                },
            });

            // Create a uniform buffer that describes the grid
            const uniformArray = new Float32Array([GRID_SIZE, GRID_SIZE]);
            const uniformBuffer = device.createBuffer({
                label: "Grid buffer",
                size: uniformArray.byteLength,
                usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
            });
            device.queue.writeBuffer(uniformBuffer, 0, uniformArray);
            
            // Create a bind group to pass the grid uniforms into the pipeline
            // Unlike vertex data which is a fixed part of the pipeline's vertex state
            // Uniforms are dynamic and can change between draw calls
            // So, we need to explicitly create a bind group to pass the uniforms into the pipeline
            const bindGroup = device.createBindGroup({
                label: "Cell renderer bind group",
                layout: cellPipeline.getBindGroupLayout(0),
                entries: [{
                    binding: 0,
                    resource: { buffer: uniformBuffer }
                }],
            });
                        
            // Clear the canvas with solid color
            const encoder = device.createCommandEncoder(); // records sequence of GPU commands to be executed later
            const pass = encoder.beginRenderPass({ // collection of draw commands that target canvas
            colorAttachments: [
                {
                    view: context.getCurrentTexture().createView(), // what to render to
                    loadOp: 'clear', // clear the texture when the pass starts
                    storeOp: 'store', // store the result after rendering
                    clearValue: { r: 0.0, g: 0.0, b: 0.4, a: 1.0 }, // dark blue color
                }
            ]
            });

            // Draw the square
            pass.setPipeline(cellPipeline);
            pass.setVertexBuffer(0, vertexBuffer);
            pass.setBindGroup(0, bindGroup);
            pass.draw(vertices.length / 2, GRID_SIZE * GRID_SIZE);
                    
            // finalize the command buffer and submits it to the GPU for execution
            pass.end()
            device.queue.submit([encoder.finish()]);
            


        </script>
    </body>
</html>
