<!DOCTYPE html>

<html>
    <head>
        <meta charset="UTF-8">
        <title>WebGPU Game of Life</title>
    </head>
    
    <body>
        <canvas width="512" height="512"></canvas>
    
        <script type="module">
            // Using module let's you use await without needing to wrap everything in an async function
            // Useful for WebGPU initialization
            
            const GRID_SIZE = 4;
            // Create a uniform buffer that describes the grid
            const uniformArray = new Float32Array([GRID_SIZE, GRID_SIZE]);
            const uniformBuffer = device.createBuffer({
                label: "Grid buffer",
                size: uniformArray.byteLength,
                usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
            });
            device.queue.writeBuffer(uniformBuffer, 0, uniformArray);


            // Canvas is where WebGPU will render to
            const canvas = document.querySelector("canvas");

            // Check if WebGPU is supported in the browser -->
            if (!navigator.gpu) {
                throw new Error("WebGPU not supported on this browser.");
            }
          
            // Request access to GPU
            const adapter = await navigator.gpu.requestAdapter();
            if (!adapter) {
                throw new Error("No appropriate GPUAdapter found.");
            }

            const device = await adapter.requestDevice();

            // Configure Canvas
            const context = canvas.getContext("webgpu"); // target where WebGPU will render to
            const canvasFormat = navigator.gpu.getPreferredCanvasFormat(); // get ideal pixel format for the canvas
            context.configure({ // configure webgpu context
                device: device,
                format: canvasFormat
            });

            
            // Define vertices
            // Typed arrays in JS lets you allocate continuous memory blocks.
            // They tend to be more perfomant than regular arrays
            // Float32Array is a typed array that stores 32-bit floating point numbers
            const vertices = new Float32Array([
                // positions
                -0.8, -0.8, // Triangle 1
                0.8, -0.8,
                0.8, 0.8,
                
                -0.8, -0.8, // Triangle 2
                0.8, 0.8,
                -0.8, 0.8,
            ]);
            
            // Create a vertex buffer
            // GPUs can't acess JS memory directly so memory must be allocated on the GPU
            // This is managed through GPUBuffer
            const vertexBuffer = device.createBuffer({
                label: "Cell vertices",
                size: vertices.byteLength,
                usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,
            });
            
            device.queue.writeBuffer(vertexBuffer, 0, vertices);
            
            // Define the vertex layout
            // Each vertex has 2 components (x, y)
            // Each component is a 32-bit float = 4 bytes
            // So 2 components x and y take 8 bytes of memory
            const vertexBufferLayout = {
                arrayStride: 8, // how far to move in memory to get to the next vertex
                attributes: [
                    {
                        format: "float32x2", // each vertext has 2 floating point numbers
                        offset: 0, // how many bytes into the vertex the attribute starts
                        shaderLocation: 0, // arbitary number from 0 - 15 to identify vertex shader
                    }
                ]
            }
            
            //  Create Shaders 
            // Code is written in WSGL (WebGPU Shading Language)
            // vertex function takes a 2D position and returns a 4D position that WebGPU needs for rendering
            // fragment function returns a color for each pixel, so red here
            
            const cellShaderModule = device.createShaderModule({
                label: "Cell shader",
                code: `
                @group(0) @binding(0) var<uniform> grid: vec2f;
                
                @vertex
                fn vertexMain(@location(0) pos: vec2f) ->
                @builtin(position) vec4f {
                    return vec4f(pos / grid, 0, 1);
                    }
                    
                    @fragment
                    fn fragmentMain() -> @location(0) vec4f {
                        return vec4f(1, 0, 0, 1);
                        }
                        
                        `
                    });
                    
                    // Create a pipeline that renders a cell
                    const cellPipeline = device.createRenderPipeline({
                        label: "Cell pipeline",
                        layout: "auto", // let webgpu decide memory layout
                        vertex: {
                            module: cellShaderModule, // pass shader program
                            entryPoint: "vertexMain", // function entrypoint @vertex
                            buffers: [vertexBufferLayout],
                        },
                        fragment: {
                            module: cellShaderModule,
                            entryPoint: "fragmentMain", // function entrypoint @fragment
                            targets: [
                                {
                                    format: canvasFormat, // pixel format to match canvas
                                }
                            ],
                        },
                    });
                    
                    // Clear the canvas with solid color
                    const encoder = device.createCommandEncoder(); // records sequence of GPU commands to be executed later
                    const pass = encoder.beginRenderPass({ // collection of draw commands that target canvas
                        colorAttachments: [
                            {
                                view: context.getCurrentTexture().createView(), // what to render to
                                loadOp: 'clear', // clear the texture when the pass starts
                                storeOp: 'store', // store the result after rendering
                                clearValue: { r: 0.0, g: 0.0, b: 0.4, a: 1.0 }, // dark blue color
                            }
                        ]
                    });

                    // Draw the square
                    pass.setPipeline(cellPipeline);
                    pass.setVertexBuffer(0, vertexBuffer);
                    pass.draw(vertices.length / 2);
                    
                    // finalize the command buffer and submits it to the GPU for execution
                    pass.end()
                    device.queue.submit([encoder.finish()]);
                    


        </script>
    </body>
</html>
